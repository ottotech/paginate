package paginate

import (
	"errors"
	"fmt"
	"reflect"
	"strings"
	"sync"
	"time"
)

var ErrPaginatorIsClosed = errors.New("paginate: Paginator is closed")

// Paginator is the interface that wraps pagination behaviors.
type Paginator interface {
	// Paginate will use the data consumed by NewPaginator or NewPaginatorWithLimit,
	// and it will return an sql command with the corresponding arguments. The operation
	// will run concurrently to improve computation speed.
	//
	// The sql command generated by Paginate should be run against the target database.
	Paginate() (sql string, args []interface{}, err error)

	NextData() bool
	Scan(dest interface{}) error
	Flush()
	GetRowPtrArgs() []interface{}

	// Response should be executed after calling SetPageCount and SetTotalResult.
	// Response will return a PaginationResponse struct containing useful information for clients
	// of the package so they can do proper and subsequent pagination operations.
	Response() PaginationResponse
}

// paginator is a concrete type that implements the Paginator interface.
type paginator struct {
	request    paginationRequest
	response   PaginationResponse
	parameters parameters

	// table is a representation of a database table and its columns.
	table interface{}

	// name is the name of the table in the database. This package will
	// infer the name of the table from the given table struct.
	name string

	// id represents the table pk in the database. This value should be
	// defined in the given table through the tag "id" (e.g. `paginator:"id"`")
	// in one of the `table` struct `fields`.
	id string

	// cols holds the names of the columns of the database table.
	// This package will infer the column names from the struct `fields`
	// of the given table and it will convert any camel case field name
	// to sneak case lowercase. So MyAwesomeField will be my_awesome_field.
	cols []string

	// fields holds the raw names of the struct "fields" of the given table.
	fields []string

	// filters holds the names of the columns of the table that the user
	// wants to filter. By default all the fields of the table struct can
	// be filtered. A user can explicitly tell paginator not to filter a
	// column by specifying the "nofilter" tag in the table struct fields.
	filters []string

	// rows holds the paginated values scanned by the Scan method in
	// go sql package. See also addRow and GetRowPtrArgs for a
	// better understanding.
	rows []interface{}

	// tmp holds the values for each row in rows. tpm will hold the values
	// temporarily everytime we run GetRowPtrArgs. We use these values to
	// scan with the Scan method from the go sql package the paginated data.
	tmp []interface{}

	// rv holds the reflection value of the given table.
	rv reflect.Value

	// totalSize represents the total number of records in the given table in
	// the database.
	totalSize int

	// pageCount represents the total number of records retrieved by paginator
	// from the database.
	pageCount int

	// closed is used by Scan. When closed == true it means that all rows
	// has been scanned to the given destinations and paginator does not have
	// the scanned rows anymore, so any further call to Scan will not work at
	// this point.
	closed bool

	// started is used by GetRowPtrArgs and Scan. When started == true it means
	// that the rows consumption has started, so no further calls to GetRowPtrArgs
	// can be done. A call to GetRowPtrArgs will panic if started == true.
	started bool

	// once is used by Scan. It's purpose is to set only once started, pageSize,
	// and run addRow the first time Scan is used.
	once sync.Once
}

func (p *paginator) Paginate() (sql string, values []interface{}, err error) {
	var s string
	c1 := make(chan whereClause)
	c3 := make(chan string)
	c4 := make(chan string)
	go createWhereClause(p.cols, p.parameters, c1)
	go createPaginationClause(p.request.pageNumber, p.request.pageSize, c3)
	go createOrderByClause(p.parameters, p.cols, c4)
	where := <-c1
	pagination := <-c3
	order := <-c4

	numArgs := len(where.args)
	placeholders := make([]interface{}, 0)
	for i := 1; i < numArgs+1; i++ {
		placeholders = append(placeholders, i)
	}

	if where.exists {
		s = "SELECT " + strings.Join(p.cols, ", ") + ", count(*) over() FROM " + p.name + where.clause + order + pagination
		s = fmt.Sprintf(s, placeholders...)
	} else {
		s = "SELECT " + strings.Join(p.cols, ", ") + ", count(*) over() FROM " + p.name + order + pagination
	}
	return s, where.args, nil
}

func (p *paginator) Response() PaginationResponse {
	p.response.PageNumber = p.request.pageNumber

	if (p.request.pageNumber * p.request.pageSize) < p.totalSize {
		p.response.NextPageNumber = p.request.pageNumber + 1
		p.response.HasNextPage = true
	}
	if (p.request.pageNumber * p.request.pageSize) == p.totalSize {
		p.response.NextPageNumber = 0
		p.response.HasNextPage = false
	}
	if p.totalSize == 0 {
		p.response.NextPageNumber = 0
		p.response.HasNextPage = false
	}
	if p.response.PageNumber > 1 {
		p.response.HasPreviousPage = true
	}

	p.response.PageCount = p.pageCount
	p.response.TotalSize = p.totalSize

	return p.response
}

func (p *paginator) validateTable() error {
	if p.rv.Type().Kind() != reflect.Struct {
		return fmt.Errorf("paginate: table should be of struct type")
	}

	if !p.rv.IsZero() {
		return fmt.Errorf("paginate: table struct should be empty with only the default zero values")
	}

	numOfIDs := 0

	// See usage below.
	countIDs := func(tags []string) int {
		s := "id"
		c := 0
		for _, tag := range tags {
			if tag == s {
				c++
			}
		}
		return c
	}

	for i := 0; i < p.rv.NumField(); i++ {
		field := p.rv.Type().Field(i)
		tags := strings.Split(field.Tag.Get("paginate"), ";")
		numOfIDs += countIDs(tags)
		fieldName := field.Name
		T := reflect.Indirect(p.rv).FieldByName(fieldName).Interface()
		switch T.(type) {
		case string:
			continue
		case int, int8, int16, int32, int64:
			continue
		case bool:
			continue
		case float32, float64:
			continue
		case time.Time:
			continue
		default:
			return fmt.Errorf("paginate: invalid type for field %q", fieldName)
		}
	}

	if numOfIDs == 0 {
		return fmt.Errorf("paginate: id has not been defined in any " +
			"of the field of the given struct")
	} else if numOfIDs > 1 {
		return fmt.Errorf("paginate: more than one id has beend defined " +
			"in the fields of the given struct")
	}

	return nil
}

func (p *paginator) getCols() {
	for i := 0; i < p.rv.NumField(); i++ {
		fieldName := p.rv.Type().Field(i).Name
		sneakName := parseCamelCaseToSnake(fieldName)
		p.cols = append(p.cols, sneakName)
	}
}

func (p *paginator) getFieldNames() {
	for i := 0; i < p.rv.NumField(); i++ {
		field := p.rv.Type().Field(i)
		fieldName := field.Name
		p.fields = append(p.fields, fieldName)
	}
}

func (p *paginator) getFilters() {
	const nofilter = "nofilter"

	hasnofilter := func(tags []string) bool {
		for _, tag := range tags {
			if tag == nofilter {
				return true
			}
		}
		return false
	}

	for i := 0; i < p.rv.NumField(); i++ {
		field := p.rv.Type().Field(i)
		tags := strings.Split(field.Tag.Get("paginate"), tagsep)
		if !hasnofilter(tags) {
			continue
		}
		sneakName := parseCamelCaseToSnake(field.Name)
		p.filters = append(p.filters, sneakName)
	}
}

func (p *paginator) getID() {
	id := ""

	hasID := func(tags []string) bool {
		for _, tag := range tags {
			if tag == "id" {
				return true
			}
		}
		return false
	}

	for i := 0; i < p.rv.NumField(); i++ {
		field := p.rv.Type().Field(i)
		tags := strings.Split(field.Tag.Get("paginate"), tagsep)
		if hasID(tags) {
			id = parseCamelCaseToSnake(field.Name)
			break
		}
	}

	p.id = id
}

func (p *paginator) getTableName() {
	name := parseCamelCaseToSnake(p.rv.Type().Name())
	p.name = name
}

func (p *paginator) GetRowPtrArgs() []interface{} {
	if p.started {
		return nil
	}
	if len(p.tmp) > 0 {
		p.addRow()
	}
	for _, fieldName := range p.fields {
		T := reflect.Indirect(p.rv).FieldByName(fieldName).Interface()
		switch T.(type) {
		case string:
			var s string
			s = ""
			p.tmp = append(p.tmp, &s)
		case int:
			var i int
			p.tmp = append(p.tmp, &i)
		case int8:
			var i8 int8
			p.tmp = append(p.tmp, &i8)
		case int16:
			var i16 int16
			i16 = 0
			p.tmp = append(p.tmp, &i16)
		case int32:
			var i32 int32
			p.tmp = append(p.tmp, &i32)
		case int64:
			var i64 int64
			p.tmp = append(p.tmp, &i64)
		case bool:
			var b bool
			p.tmp = append(p.tmp, &b)
		case float32:
			var f32 float32
			p.tmp = append(p.tmp, &f32)
		case float64:
			var f64 float64
			p.tmp = append(p.tmp, &f64)
		case time.Time:
			var t time.Time
			p.tmp = append(p.tmp, &t)
		}
	}

	// As an special case in tmp we will always
	// append at the end p.totalSize whose value
	// is going to be retrieved when the query gets
	// executed.
	p.tmp = append(p.tmp, &p.totalSize)
	return p.tmp
}

func (p *paginator) addRow() {
	row := p.table
	rv := reflect.ValueOf(&row).Elem()
	tmpRow := reflect.New(rv.Elem().Type()).Elem()
	tmpRow.Set(rv.Elem())

	// The below loop condition expression is len(tmp)-1
	// because of the extra field we are adding in tmp: totalSize.
	// len(tmp)-1  will give use exactly the field elements we want.
	for i := 0; i < len(p.tmp)-1; i++ {
		val := reflect.ValueOf(p.tmp[i]).Elem()
		tmpRow.FieldByName(p.fields[i]).Set(val)
		rv.Set(tmpRow)
	}

	// We need to clear p.tmp so we can reuse it later in another call
	// to addRow.
	p.tmp = make([]interface{}, 0)

	p.rows = append(p.rows, row)
}

func (p *paginator) NextData() bool {
	if len(p.tmp) > 0 {
		p.addRow()
	}
	return len(p.rows) > 0
}

func (p *paginator) Scan(dest interface{}) error {
	if dest == nil {
		return fmt.Errorf("paginate: cannot pass nil as dest")
	}

	if p.closed {
		return ErrPaginatorIsClosed
	}

	if err := p.validateDest(dest); err != nil {
		return err
	}

	if len(p.rows) == 0 {
		return errors.New("paginate: Scan called without calling NextData")
	}

	p.once.Do(func() {
		// Order matters. If there is some data left in p.tmp
		// p.addRow will add a new row with the tmp data affecting
		// therefore the value of p.pageCount.
		if len(p.tmp) > 0 {
			p.addRow()
		}
		p.started = true
		p.pageCount = len(p.rows)
	})

	destrv := reflect.ValueOf(dest)

	row := p.rows[0]
	for _, field := range p.fields {
		val := reflect.ValueOf(row).FieldByName(field)
		destrv.Elem().FieldByName(field).Set(val)
	}

	// Let's remove the row from p.rows.
	p.rows = p.rows[1:]

	// When all rows are consumed, we "close" the Paginator Scanner.
	if len(p.rows) == 0 {
		p.closed = true
	}

	return nil
}

func (p *paginator) validateDest(dest interface{}) error {
	destrv := reflect.ValueOf(dest)

	if destrv.Kind() != reflect.Ptr {
		return fmt.Errorf("paginate: the given "+
			"destination should be a pointer of type *%s; got %s",
			p.rv.Type().String(), destrv.Type().String())
	}

	destri := reflect.Indirect(destrv)

	if p.rv.Type() != destri.Type() {
		return fmt.Errorf("paginate: the given "+
			"destination should be a pointer of type *%s; got %s",
			p.rv.Type().String(), destri.Type().String())
	}

	if !destri.IsZero() {
		return fmt.Errorf("paginate: the given "+
			"destination should be the zero value of *%s",
			p.rv.Type().String())
	}

	return nil
}

func (p *paginator) Flush() {
	p.rows = make([]interface{}, 0)
	p.tmp = make([]interface{}, 0)
	p.totalSize = 0
	p.pageCount = 0
	p.closed = false
	p.started = false
}
