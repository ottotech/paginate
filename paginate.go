package paginate

import (
	"errors"
	"fmt"
	"net/url"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"
	"unicode"
)

var ErrPaginatorIsClosed = errors.New("paginate: Paginator is closed")

// Paginator is the interface that wraps pagination behaviors.
type Paginator interface {
	// Paginate will use the data consumed by NewPaginator or NewPaginatorWithLimit,
	// and it will return an sql command with the corresponding arguments. The operation
	// will run concurrently to improve computation speed.
	//
	// The sql command generated by Paginate should be run against the target database.
	Paginate() (sql string, args []interface{}, err error)

	Next() bool
	Scan(dest interface{}) error
	Flush()
	GetRowPtrArgs() []interface{}

	// Response should be executed after calling SetPageCount and SetTotalResult.
	// Response will return a PaginationResponse struct containing useful information for clients
	// of the package so they can do proper and subsequent pagination operations.
	Response() PaginationResponse
}

// paginator is a concrete type that implements the Paginator interface.
type paginator struct {
	request    paginationRequest
	response   PaginationResponse
	parameters parameters
	pageSize   int

	// table is a representation of a database table and its columns.
	table interface{}

	// name is the name of the table in the database. This package will
	// infer the name of the table from the given table struct.
	name string

	// id represents the table pk in the database. This value should be
	// defined in the given table through the tag "id" (e.g. `paginator:"id"`")
	// in one of the `table` struct `fields`.
	id string

	// cols holds the names of the columns of the database table.
	// This package will infer the column names from the struct `fields`
	// of the given table and it will convert any camel case field name
	// to sneak case lowercase. So MyAwesomeField will be my_awesome_field.
	cols []string

	// fields holds the raw names of the struct "fields" of the given table.
	fields []string

	// filters holds the names of the columns of the table that the user
	// wants to filter. By default all the fields of the table struct can
	// be filtered. A user can explicitly tell paginator not to filter a
	// column by specifying the "nofilter" tag in the table struct fields.
	filters []string

	// rows holds the paginated values scanned by the Scan method in
	// go sql package. See also addRow and GetRowPtrArgs for a
	// better understanding.
	rows []interface{}

	// tmp holds the values for each row in rows. tpm will hold the values
	// temporarily everytime we run GetRowPtrArgs. We use these values to
	// scan with the Scan method from the go sql package the paginated data.
	tmp []interface{}

	// rv holds the reflection value of the given table.
	rv reflect.Value

	// totalSize represents the total number of records in the given table in
	// the database.
	totalSize int

	// pageCount represents the total number of records retrieved by paginator
	// from the database.
	pageCount int

	// closed is used by Scan. When closed == true it means that all rows
	// has been scanned to the given destinations and paginator does not have
	// the scanned rows anymore, so any further call to Scan will not work at
	// this point.
	closed bool

	// started is used by GetRowPtrArgs and Scan. When started == true it means
	// that the rows consumption has started, so no further calls to GetRowPtrArgs
	// can be done. A call to GetRowPtrArgs will panic if started == true.
	started bool

	// once is used by Scan. It's purpose is to set only once started, pageSize,
	// and run addRow the first time Scan is used.
	once sync.Once
}

// NewPaginator creates a Paginator object ready to paginate data from a database table.
//
// NewPaginator will try to get the page size for the paginator result from the request url
// If it fails to get the parameter from the request url, it will use the constant PageSize.
func NewPaginator(table interface{}, tableName string, u url.URL) (Paginator, error) {
	p := &paginator{table: table, rv: reflect.ValueOf(table)}

	// Order matters. Validation should happen before getting
	// all the data to initialize the Paginator.
	if err := p.validateTable(); err != nil {
		return p, err
	}
	p.getCols()
	p.getFieldNames()
	p.getFilters()
	p.getID()
	if tableName == "" {
		p.getTableName()
	} else {
		p.name = strings.TrimSpace(tableName)
	}

	c := make(chan parameters)
	go getParameters(p.cols, u, c)
	v := u.Query()
	p.request = getRequestData(v)
	p.parameters = <-c
	return p, nil
}

// NewPaginatorWithLimit creates a Paginator object ready to paginate data from a database table.
//
// NewPaginatorWithLimit specifies explicitly the page size we want to use for the pagination results.
func NewPaginatorWithLimit(pageSize int, table interface{}, tableName string, u url.URL) (Paginator, error) {
	p := &paginator{table: table, rv: reflect.ValueOf(table)}

	// Order matters. Validation should happen before getting
	// all the data to initialize the Paginator.
	if err := p.validateTable(); err != nil {
		return p, err
	}
	p.getCols()
	p.getFieldNames()
	p.getFilters()
	p.getID()
	if tableName == "" {
		p.getTableName()
	} else {
		p.name = strings.TrimSpace(tableName)
	}
	if pageSize <= 0 {
		pageSize = PageSize
	}
	c := make(chan parameters)
	go getParameters(p.cols, u, c)
	v := u.Query()
	p.request = getRequestData(v)
	p.request.pageSize = pageSize // here we override the pageSize
	p.parameters = <-c
	return p, nil
}

func (p *paginator) Paginate() (sql string, values []interface{}, err error) {
	var s string
	c1 := make(chan whereClause)
	c3 := make(chan string)
	c4 := make(chan string)
	go createWhereClause(p.cols, p.parameters, c1)
	go createPaginationClause(p.request.pageNumber, p.request.pageSize, c3)
	go createOrderByClause(p.parameters, p.cols, c4)
	where := <-c1
	pagination := <-c3
	order := <-c4

	numArgs := len(where.args)
	placeholders := make([]interface{}, 0)
	for i := 1; i < numArgs+1; i++ {
		placeholders = append(placeholders, i)
	}

	if where.exists {
		s = "SELECT " + strings.Join(p.cols, ", ") + ", count(*) over() FROM " + p.name + where.clause + order + pagination
		s = fmt.Sprintf(s, placeholders...)
	} else {
		s = "SELECT " + strings.Join(p.cols, ", ") + ", count(*) over() FROM " + p.name + order + pagination
	}
	return s, where.args, nil
}

func (p *paginator) Response() PaginationResponse {
	p.response.PageNumber = p.request.pageNumber

	if (p.request.pageNumber * p.request.pageSize) < p.response.TotalSize {
		p.response.NextPageNumber = p.request.pageNumber + 1
		p.response.HasNextPage = true
	}
	if (p.request.pageNumber * p.request.pageSize) == p.response.TotalSize {
		p.response.NextPageNumber = 0
		p.response.HasNextPage = false
	}
	if p.response.TotalSize == 0 {
		p.response.NextPageNumber = 0
		p.response.HasNextPage = false
	}
	if p.response.PageNumber > 1 {
		p.response.HasPreviousPage = true
	}
	return p.response
}

func getParameters(colNames []string, u url.URL, c chan parameters) {
	decodedURL, _ := url.PathUnescape(u.String())
	list := make(parameters, 0)
	i := strings.Index(decodedURL, "?")
	if i == -1 {
		c <- list
		return
	}

	getP := func(key, val, char string) (bool, parameter) {
		p := parameter{}
		if strings.Contains(val, char) {
			if val[:len(char)] == char && len(val) > len(char) {
				p.name = key
				p.sign = char
				p.value = val[len(char):]
				return true, p
			}
		}
		return false, p
	}
	params := strings.Split(decodedURL[i+1:], "&")
	for _, n := range colNames {
		for _, p := range params {
			if len(p) <= len(n) {
				continue
			}
			key, value := p[:len(n)], p[len(n):]
			if key != n {
				continue
			}
			// order matters
			if ok, newP := getP(key, value, gte); ok {
				list = append(list, newP)
				continue
			}
			if ok, newP := getP(key, value, lte); ok {
				list = append(list, newP)
				continue
			}
			if ok, newP := getP(key, value, ne); ok {
				list = append(list, newP)
				continue
			}
			if ok, newP := getP(key, value, gt); ok {
				list = append(list, newP)
				continue
			}
			if ok, newP := getP(key, value, lt); ok {
				list = append(list, newP)
				continue
			}
			if ok, newP := getP(key, value, eq); ok {
				list = append(list, newP)
				continue
			}
		}
	}
	// as an special case we need to also get our custom sort parameter
	sort := "sort"
	for _, p := range params {
		if len(p) <= len(sort) {
			continue
		}
		key, value := p[:len(sort)], p[len(sort):]
		if key != sort {
			continue
		}
		if ok, newP := getP(key, value, eq); ok {
			list = append(list, newP)
			continue
		}
	}
	c <- list
}

func getRequestData(v url.Values) paginationRequest {
	p := paginationRequest{}
	if page := v.Get("page"); page != "" {
		page, err := strconv.Atoi(page)
		if err != nil {
			page = 1
		}
		if page <= 0 {
			page = 1
		}
		p.pageNumber = page
	} else {
		p.pageNumber = 1
	}

	if pageSize := v.Get("page_size"); pageSize != "" {
		pageSize, err := strconv.Atoi(pageSize)
		if err != nil {
			pageSize = PageSize
		}
		if pageSize <= 0 {
			pageSize = PageSize
		}
		p.pageSize = pageSize
	} else {
		p.pageSize = PageSize
	}
	return p
}

func createWhereClause(colNames []string, params parameters, c chan whereClause) {
	w := whereClause{}
	var WHERE = " WHERE "
	var AND = " AND "
	var separator string
	var clauses []string
	var values []interface{}

	// map all db column names with the url parameters
	for _, name := range colNames {
		for _, p := range params {
			if p.name == name {
				values = append(values, p.value)
				clauses = append(clauses, p.name+" "+p.sign+" $%v")
			}
		}
	}
	// use appropriate `separator` to join the clauses
	if len(clauses) == 1 {
		separator = ""
	} else {
		separator = AND
	}
	// let's map the clause and args to the whereClause struct, and specify if there were some where clauses at all
	w.clause = WHERE + strings.Join(clauses, separator)
	w.args = values
	w.exists = len(clauses) > 0
	c <- w
}

func createPaginationClause(pageNumber int, pageSize int, c chan string) {
	var clause string
	var offset int

	if pageSize > PageSize {
		pageSize = PageSize
	} else if pageSize < 0 {
		pageSize = PageSize
	}

	clause += fmt.Sprintf(" LIMIT %v ", pageSize)

	if pageNumber < 0 || pageNumber == 0 || pageNumber == 1 {
		offset = 0
	} else {
		offset = pageSize * (pageNumber - 1)
	}

	clause += fmt.Sprintf("OFFSET %v", offset)
	c <- clause
}

func createOrderByClause(params parameters, colNames []string, c chan string) {
	var ASC = "ASC"
	var DESC = "DESC"
	clauses := make([]string, 0)
	sort, exists := params.getParameter("sort")
	if !exists {
		c <- " ORDER BY id"
		return
	}
	fields := strings.Split(sort.value, ",")
	for _, v := range fields {
		orderBy := string(v[0])
		field := v[1:]
		for _, f := range colNames {
			if f == "id" {
				// we will always order the records by ID (see below). In order
				// to keep the same order between pages or results
				continue
			}
			if field == f {
				if orderBy == "+" {
					clauses = append(clauses, field+" "+ASC)
				}
				if orderBy == "-" {
					clauses = append(clauses, field+" "+DESC)
				}
			}
		}
	}
	clauses = append(clauses, "id")
	clauseSTR := strings.Join(clauses, ",")
	c <- " ORDER BY " + clauseSTR
}

// parseCamelCaseToSnake parses a camelcase string to a snake case.
// So for example, if we use as input for this function the following
// string "myCamelCaseVar" the output would be "my_camel_case_var".
func parseCamelCaseToSnake(camelCase string) string {
	var s []string
	for i := len(camelCase) - 1; i >= 0; i-- {
		if unicode.IsUpper(rune(camelCase[i])) {
			s = append(s, camelCase[i:])
			camelCase = camelCase[:i]
		}
	}
	var orderedSlice []string
	for i := len(s) - 1; i >= 0; i-- {
		orderedSlice = append(orderedSlice, s[i])
	}
	return strings.ToLower(strings.Join(orderedSlice, "_"))
}

func (p *paginator) validateTable() error {
	if p.rv.Type().Kind() != reflect.Struct {
		return fmt.Errorf("paginate: table should be of struct type")
	}

	if !p.rv.IsZero() {
		return fmt.Errorf("paginate: table struct should be empty with only the default zero values")
	}

	numOfIDs := 0

	// See usage below.
	countIDs := func(tags []string) int {
		s := "id"
		c := 0
		for _, tag := range tags {
			if tag == s {
				c++
			}
		}
		return c
	}

	for i := 0; i < p.rv.NumField(); i++ {
		field := p.rv.Type().Field(i)
		tags := strings.Split(field.Tag.Get("paginate"), ";")
		numOfIDs += countIDs(tags)
		fieldName := field.Name
		T := reflect.Indirect(p.rv).FieldByName(fieldName).Interface()
		switch T.(type) {
		case string:
			continue
		case int, int8, int16, int32, int64:
			continue
		case bool:
			continue
		case float32, float64:
			continue
		case time.Time:
			continue
		default:
			return fmt.Errorf("paginate: invalid type for field %q", fieldName)
		}
	}

	if numOfIDs == 0 {
		return fmt.Errorf("paginate: id has not been defined in any " +
			"of the field of the given struct")
	} else if numOfIDs > 1 {
		return fmt.Errorf("paginate: more than one id has beend defined " +
			"in the fields of the given struct")
	}

	return nil
}

func (p *paginator) getCols() {
	for i := 0; i < p.rv.NumField(); i++ {
		fieldName := p.rv.Type().Field(i).Name
		sneakName := parseCamelCaseToSnake(fieldName)
		p.cols = append(p.cols, sneakName)
	}
}

func (p *paginator) getFieldNames() {
	for i := 0; i < p.rv.NumField(); i++ {
		field := p.rv.Type().Field(i)
		fieldName := field.Name
		p.fields = append(p.fields, fieldName)
	}
}

func (p *paginator) getFilters() {
	const nofilter = "nofilter"

	hasnofilter := func(tags []string) bool {
		for _, tag := range tags {
			if tag == nofilter {
				return true
			}
		}
		return false
	}

	for i := 0; i < p.rv.NumField(); i++ {
		field := p.rv.Type().Field(i)
		tags := strings.Split(field.Tag.Get("paginate"), tagsep)
		if !hasnofilter(tags) {
			continue
		}
		sneakName := parseCamelCaseToSnake(field.Name)
		p.filters = append(p.filters, sneakName)
	}
}

func (p *paginator) getID() {
	id := ""

	hasID := func(tags []string) bool {
		for _, tag := range tags {
			if tag == "id" {
				return true
			}
		}
		return false
	}

	for i := 0; i < p.rv.NumField(); i++ {
		field := p.rv.Type().Field(i)
		tags := strings.Split(field.Tag.Get("paginate"), tagsep)
		if hasID(tags) {
			id = parseCamelCaseToSnake(field.Name)
			break
		}
	}

	p.id = id
}

func (p *paginator) getTableName() {
	name := parseCamelCaseToSnake(p.rv.Type().Name())
	p.name = name
}

func (p *paginator) GetRowPtrArgs() []interface{} {
	if p.started {
		panic("paginate: GetRowPtrArgs cannot be called after calling Scan")
	}
	if len(p.tmp) > 0 {
		p.addRow()
	}
	for _, fieldName := range p.fields {
		T := reflect.Indirect(p.rv).FieldByName(fieldName).Interface()
		switch T.(type) {
		case string:
			var s string
			s = ""
			p.tmp = append(p.tmp, &s)
		case int:
			var i int
			p.tmp = append(p.tmp, &i)
		case int8:
			var i8 int8
			p.tmp = append(p.tmp, &i8)
		case int16:
			var i16 int16
			i16 = 0
			p.tmp = append(p.tmp, &i16)
		case int32:
			var i32 int32
			p.tmp = append(p.tmp, &i32)
		case int64:
			var i64 int64
			p.tmp = append(p.tmp, &i64)
		case bool:
			var b bool
			p.tmp = append(p.tmp, &b)
		case float32:
			var f32 float32
			p.tmp = append(p.tmp, &f32)
		case float64:
			var f64 float64
			p.tmp = append(p.tmp, &f64)
		case time.Time:
			var t time.Time
			p.tmp = append(p.tmp, &t)
		}
	}

	// As an special case in tmp we will always
	// append at the end p.totalSize whose value
	// is going to be retrieved when the query gets
	// executed.
	p.tmp = append(p.tmp, &p.totalSize)
	return p.tmp
}

func (p *paginator) addRow() {
	row := p.table
	rv := reflect.ValueOf(&row).Elem()
	tmpRow := reflect.New(rv.Elem().Type()).Elem()
	tmpRow.Set(rv.Elem())

	// The below loop condition expression is len(tmp)-1
	// because of the extra field we are adding in tmp: totalSize.
	// len(tmp)-1  will give use exactly the field elements we want.
	for i := 0; i < len(p.tmp)-1; i++ {
		val := reflect.ValueOf(p.tmp[i]).Elem()
		tmpRow.FieldByName(p.fields[i]).Set(val)
		rv.Set(tmpRow)
	}

	// We need to clear p.tmp so we can reuse it later in another call
	// to addRow.
	p.tmp = make([]interface{}, 0)

	p.rows = append(p.rows, row)
}

func (p *paginator) Next() bool {
	if len(p.tmp) > 0 {
		p.addRow()
	}
	return len(p.rows) > 0
}

func (p *paginator) Scan(dest interface{}) error {
	if dest == nil {
		return fmt.Errorf("paginate: cannot pass nil as dest")
	}

	if p.closed {
		return ErrPaginatorIsClosed
	}

	if err := p.validateDest(dest); err != nil {
		return err
	}

	if len(p.rows) == 0 {
		return errors.New("paginate: Scan called without calling Next")
	}

	p.once.Do(func() {
		// Order matters. If there is some data left in p.tmp
		// p.addRow will add a new row with the tmp data affecting
		// therefore the value of p.pageCount.
		if len(p.tmp) > 0 {
			p.addRow()
		}
		p.started = true
		p.pageCount = len(p.rows)
	})

	destrv := reflect.ValueOf(dest)

	row := p.rows[0]
	for _, field := range p.fields {
		val := reflect.ValueOf(row).FieldByName(field)
		destrv.Elem().FieldByName(field).Set(val)
	}

	// Let's remove the row from p.rows.
	p.rows = p.rows[1:]

	// When all rows are consumed, we "close" the Paginator Scanner.
	if len(p.rows) == 0 {
		p.closed = true
	}

	return nil
}

func (p *paginator) validateDest(dest interface{}) error {
	destrv := reflect.ValueOf(dest)

	if destrv.Kind() != reflect.Ptr {
		return fmt.Errorf("paginate: the given "+
			"destination should be a pointer of type *%s; got %s",
			p.rv.Type().String(), destrv.Type().String())
	}

	destri := reflect.Indirect(destrv)

	if p.rv.Type() != destri.Type() {
		return fmt.Errorf("paginate: the given "+
			"destination should be a pointer of type *%s; got %s",
			p.rv.Type().String(), destri.Type().String())
	}

	if !destri.IsZero() {
		return fmt.Errorf("paginate: the given "+
			"destination should be the zero value of *%s",
			p.rv.Type().String())
	}

	return nil
}

func (p *paginator) Flush() {
	p.rows = make([]interface{}, 0)
	p.tmp = make([]interface{}, 0)
	p.totalSize = 0
	p.pageCount = 0
	p.closed = false
	p.started = false
}
